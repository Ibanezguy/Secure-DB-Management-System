#!/bin/sh
##################################################
#Filename: admin_functions
#This file contains functions for admin_script
#Programmed by Joshua Konecki
#Project Start: 25 April 2017
#Updated 3 May 2017
##################################################

#type will be either s, c, or r for
#"screen", "command", or "report"
typeLet=
typeWord=

select_user()
{
userfound=0
userArray=()
until [ $userfound -eq 1 ]; do
  clear
  echo -n "                       "
  echo "Here are the available usernames:"
  userArray=( `isql ssmistest 2>/dev/null <<HEREDOC
  OUTPUT to PIPE "cat" without headings
  SELECT user.name
    FROM user
       ORDER BY name ASC
HEREDOC`)
  echo ""  
  for users in  ${userArray[@]}; do
    printf " %-25s %-25s %-25s \n" $users
  done | pr --columns=2 -T

  userfound=0
  tput cup 21 0
  echo " Enter a username then press ENTER"
  echo -n " ->:"
  read user
  #Search for user name
  for i in ${allUsers[@]}; do
    if [ "$i" = "$user" ]; then
      userfound=1
    fi
  done
    if [ $userfound -eq 0 ]; then
      echo "User not found in database. Try again."
      echo "Press ENTER:"
      read
    fi
done

flag=1
until [ $flag -eq 0 ]; do
  #Clear prompt then ask for s, c, or r
  tput cup 21 0
  echo "                                      "
  tput cup 21 0
  echo -n " Enter s for Screens, c for Commands, or r"
  echo -n " for Reports."
  tput cup 22 4
  echo "                   "
  tput cup 22 4
  read typeLet

  case $typeLet in
  s)
    typeWord="screen"
    flag=0
  ;;
  c)
    typeWord="command"
    flag=0
  ;;
  r)
    typeWord="report"
    flag=0
  ;;
  *)
    :
  esac
done
}
get_users()
{
allUsers=()
allUsers=(`isql ssmistest 2>/dev/null <<HEREDOC
OUTPUT to PIPE "cat" without headings
SELECT user.name
  FROM user
HEREDOC`)
}
#The following function grabs allowed screens
#and stores screen information in an array
retrieve_screens()
{
#Retreive user.id, store in userid
userid=`isql ssmistest 2>/dev/null <<HEREDOC
OUTPUT TO PIPE "cat" without headings
SELECT user.id
  FROM user
    WHERE user.name = '$1'
HEREDOC`

#Build array of screens available to user
#First unload to file

index=0
userScreens=()
  isql ssmistest 2>/dev/null <<HEREDOC
  UNLOAD TO "userScreens.$$"
  SELECT screen.screen_id 
         || "|" || RTRIM(screen.description)
         || "|" || RTRIM(screen.command)
         || "|" || screen.read_only
    FROM screen 
      JOIN permission
        ON permission.user_id = $userid
          WHERE screen.type = '$typeLet'
          AND screen.screen_id = permission.screen_id
  ORDER BY screen.screen_id ASC
HEREDOC
#Remove backslashes generated by informix
sed -i 's/\\//g' userScreens.$$
  
#Read file contents into array
OLD_IFS=$IFS
IFS=$'\n'
while read -r line || [[ -n "$line" ]]; do
  userScreens+=($line)
done < "userScreens.$$"

IFS=$OLD_IFS

#Delete file
rm userScreens.$$

#Build array of screens not available to user
canAdd=()
containsDups=()
readOnlyList=()
alreadyAddedList=()
isql ssmistest 2>/dev/null <<HEREDOC
UNLOAD TO "canAdd.$$"
SELECT UNIQUE screen.screen_id
  || "|" ||
  RTRIM(screen.description)
  || "|" ||
  RTRIM(screen.command)
  || "|" ||
  screen.read_only
  FROM screen
    WHERE screen.description
    NOT IN
    (
     SELECT screen.description
     FROM permission
       JOIN screen
         ON permission.screen_id = screen.screen_id
           WHERE permission.user_id = $userid
    )
    AND screen.type = '$typeLet'
HEREDOC
sed -i 's/\\//g' canAdd.$$

#Read file contents into array
#Will contain duplicates due to read-only versions
OLD_IFS=$IFS
IFS=$'\n'
while read -r line; do
  containsDups+=($line)
done < canAdd.$$

#delete the file 
rm canAdd.$$

for i in ${containsDups[@]}; do
  elementName=`echo "$i" | cut -d "|" -f2`

  #Search alreadyAddedList for elementName
  #If the name is not in the list, add
  #addElement to canAdd 
  alreadyAddedFlag=0 
  for j in ${alreadyAddedList[@]}; do
    if [ "$j" == "$elementName" ]; then
      alreadyAddedFlag=1
    fi
  done

  if [ $alreadyAddedFlag -eq 0 ]; then
    canAdd+=("$i")
    alreadyAddedList+=("$elementName")
  else
    readOnlyList+=("$elementName")
  fi
done

IFS=$OLD_IFS
}
#Note: userid is initialized by retrieve_screens()
#displays menu options for the user
display_screens()
{
displayArray=()
index=0
OLD_IFS=$IFS
IFS=$'\n'
for i in ${userScreens[@]}; do
  entry=`echo -n $(( index + 1 ))`
  entry+=`echo -n ')'`
  entry+=`echo -n ${userScreens[index]} | cut -d '|' -f2`
  #Print "(read-only)" if screen is r-only for user
  isReadOnly=`echo ${userScreens[index]} | cut -d '|' -f4`
  if [ "$isReadOnly" -eq 1 ]; then
    entry+=`echo "(Read-Only)"`
  fi
  displayArray+=("$entry")
  ((index++))
done

for desc in "${displayArray[@]}"; do
  printf " %-38s\n" $desc
done |  pr --columns=2  --length=15 -T
}

#displays menu options not available to user
display_noaccess()
{
OLD_IFS=$IFS
IFS=$'\n'
noAccessArray=()
readOnlyFlag=0
index=0
asterisk="*"

for i in "${canAdd[@]}"; do
  #Element is a single addable screen with a number affixed.
  element=`echo -n $(( index + 1 ))`
  element+=`echo -n ')'`
  noAccessName=`echo ${canAdd[index]} | cut -d "|" -f2`
  element+=$noAccessName
  #Check for a read only option
  readOnlyFlag=0
  for j in ${readOnlyList[@]}; do
    if [ "$j" == "$noAccessName" ]; then
      readOnlyFlag=1
    fi
  done
  if [ $readOnlyFlag -eq 0 ]; then
    #Not in read only array, just display name
    noAccessArray+=($element)
  else
    #Read only option exists, display asterisk
    noAccessArray+=($element$asterisk)
  fi
   
  
IFS=$OLD_IFS
  #Print * if read-only is available
((index++))
done

for elem in "${noAccessArray[@]}"; do
  printf " %-38s \n" $elem
done | pr --columns=2 --length=15 -T

}

add_permissions()
{
#Import array
declare -a addArray=("${!1}")

for i in "${addArray[@]}"; do
  #Extract screen info into variables
  screenName=`echo $i | cut -d "|" -f1`
  readOnly=`echo $i | cut -d "|" -f2`

  #Find screenID corresponding to name selected and
  #read-only choice selected.
  screenID=`isql ssmistest 2>/dev/null <<HEREDOC
  OUTPUT to PIPE "cat" without headings
  SELECT screen_id
    FROM screen
      WHERE description = "$screenName"
      AND read_only = $readOnly
HEREDOC`

  #Insert permission    
  isql ssmistest  2>/dev/null <<HEREDOC
  INSERT INTO permission
    VALUES ($userid,$screenID)
HEREDOC
  #namelist will hold the tables required for the screen
  #currently being added
  nameList=()
  #TODO Grant appropriate privileges for the user
  #Fill vector with required table names for added
  #screen
  #If readOnly, then only SELECT is granted
  nameList=(`isql ssmistest 2>/dev/null <<HEREDOC
  OUTPUT to PIPE "cat" without headings
  SELECT TRIM(table_name)
    FROM dependency
      WHERE screen_id = $screenID
HEREDOC`)
  #Read Only Case
  if [ $readOnly -eq 1 ]; then
    for j in "${nameList[@]}"; do
      isql ssmistest 2>/dev/null <<HEREDOC
      GRANT SELECT
        ON $j
          TO $user
HEREDOC
    done
  #Not read only case
  else
    for j in "${nameList[@]}"; do
      isql ssmistest 2>/dev/null <<HEREDOC
      GRANT SELECT, ALTER, INSERT, DELETE, UPDATE
        ON $j
          TO $user
HEREDOC
    done
  fi

done
}

remove_permissions()
{
revokeList=()
#Import array
removeArray=("$@")
for i in "${removeArray[@]}"; do
  isql ssmistest 2>/dev/null <<HEREDOC
  DELETE FROM permission
    WHERE permission.user_id = $userid
    AND permission.screen_id = $i
HEREDOC
done
#Build array of objects to revoke from user
#Retain objects required for other screens
removeArray=(`isql ssmistest 2>/dev/null <<HEREDOC
OUTPUT TO PIPE "cat" without headings
SELECT UNIQUE table_name
  FROM dependency
    WHERE table_name
    NOT IN(
       SELECT table_name
         FROM permission join dependency
           ON permission.screen_id = dependency.screen_id
             WHERE permission.user_id = $userid
          )
HEREDOC`)
#Revoke object permissions
for obj in "${removeArray[@]}"; do
  isql ssmistest 2>/dev/null <<HEREDOC
  REVOKE SELECT, ALTER, INSERT, DELETE, UPDATE
    ON $obj
      FROM $user
HEREDOC
done
}



